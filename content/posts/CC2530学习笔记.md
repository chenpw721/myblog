+++
title = 'CC2530学习笔记'
date = 2024-09-15T16:42:04+08:00
draft = false
tags = ["CC2530", "应用开发"]
categories = ["学习笔记"]

+++

>   需要使用的软件有:
>
>   -   IAR Embedded Workbench IDE
>
>   -   SmartRF Flash Programmer
>
>   硬件:
>
>   -   一个CC Debugger仿真器、USB充电器
>
>   -   蓝色zigbee智能节点盒及其充电器
>
>   -   一台装有职业院校技能大赛物联网专用win10系统的PC

## IAR创建工程文件

1.   创建一个空目录
2.   打开IAR软件，创建一个空workspace(工作区) `File -> New -> Workspace`
3.   创建工程`Project -> Create New Project... -> Tool chain 选8051, Empty project -> OK -> 弹出的窗口找到新建的空目录，把保存文件名字改下 -> 保存` 
4.   基础设置`在软件的左边Workspace区的工程文件上右击 -> 选Options... -> 在Device框 点击右边的 ...  -> 弹出窗口下拉找到Texas Instruments打开 -> 选CC2530F2256.i51文件打开 -> 在Debugger栏 -> Driver下拉菜单找到Texas Instruments点击 -> 在Linker栏 -> Output -> Output file -> 勾选Override default -> 文件名可以不改，把后缀名改成.hex就行 -> Format -> 勾选Other单选框，Output format默认inter-extended，如果不是，请改正 -> OK`

1.   新建文件，然后把文件保存到空目录下`File -> New -> File` 
2.   `右击左边的工程文件 -> Add -> Add "main.c"`: main.c是新建的文件
3.   创建eww工作区文件`Project -> Rebuild All -> 在当前目录下保存`



## 将寄存器中的某些位清0或置1

>   基本思路: 将要操作的位置为1，如果是与运算，则要使用到取反(`~`)操作符
>
>   需要用到16进制的8421法则

### 将某些位置1同时不影响其他位

**或**操作`|=`：

: 任何值与0相或，保持原值；

: 任何值与1相或，结果为1；

### 将某些位置0同时不影响其他位

**与**操作`&=`:

: 任何值与1相与，保持原值；

: 任何值与0相与，结果为0;

## CC2530端口引脚概述

-   采用QFN40封装，有40个引脚。

-   有21个数字I/O端口，其中P0和P1是8个引脚，P2仅有5个可以使用。
-   实际开发可用I/O端口只有17个
-   可配置为通用I/O端口，或外部设备I/O
-   输入端口具备上拉或下拉能力
-   每个I/O端口都可以配置成外围中断源的输入引脚
-   P1_0和P1_1都没有上拉/下拉能力
-   P1_0和P1_1具备20mA搞驱动输出，其余I/O引脚是4mA的驱动能力

在程序编写中，引入头文件`#include <iocc2530.h>`

与通用I/O端口相关的常用寄存器有下面4个：

1.   ![P1端口](/img/P1端口SEL&DIR&INP.jpg)
2.   PxSEL: **<u>端口功能选择</u>**，设置端口是通用I/O还是外设功能端口。置为0，端口设置为通用I/O模式；置为1，端口设置为外设功能
3.   PxDIR: <u>**端口方向选择**</u>，作为通用I/O时，用来***设置数据的传输方向***。置为0，输入；置为1，输出
4.   PxINP: 作为通用输入端口时，<u>**选择输入模式**</u>是<u>*上拉*</u>、<u>*下拉*</u>还是<u>*三态*</u>(高电平、低电平、高阻态)。置为0，上拉/下拉；置为1，三态
     1.   P0INP，对上拉/下拉控制，需要结合P2INP实现
     1.   ![](/img/P2INP.jpg)

5.   Px: 数据端口，用来**控制端口的输入**或**获取端口的输入**

P0SEL&=~0x06;

P0DIR|=0x06;

P0INP&=~0x06;

P2INP&=~0x20;

## 按键扫描

基本原理：

: 按键的两个引脚，一端**通过电阻上拉到高电平**，一端**接地**

: **没有按键按下**时，输入引脚为<u>高电平</u>；同理，**按下时**，则为<u>低电平</u>

: 扫描原理：通过<u>反复读取按键输入引脚的信号</u>，然后**识别高低电平**来判断**是否有按键触发**

### 按键去抖动

>    通过这个操作可以规避一些干扰信号，从而获取真实的按键触发信号

去抖动原理：

>   由于抖动产生的低电平往往都很短，所以可以分两次检测，如果第一次是低电平，延迟一会，进一步判断，如果还是低电平，则为真实信号，否则为干扰

代码实例：

```c
uint Key_Check(void){
    //按下K1为低电平，置为0；未按下K1为高电平，置为1
    if(K1 == 0){
        Delay(5000);
        if(K1 == 0){
            return(0);
        }
	}
    return(1);
}

```

## cc2530的中断系统

![cc2530的中断系统](/img/cc2530中断系统.jpg)

![cc2530中断系统的结构图](/img/cc2530中断系统结构图.jpg)

cc2530的P0、P1、P2端口中的每个引脚都具有**外部中断输入功能**，要使某些引脚具有外部中断功能，需要对**IENx寄存器、PxIEN寄存器和PICTL寄存器**进行适当的设置

: PxIEN寄存器**外部中断功能**

: PICTL寄存器**端口输入信号控制**

P0、P1和P2端口分别使用**P0IF、P1IF和P2IF**作为**中断标志位**，端口组上的任何一个引脚产生**外部中断**时，都会将**对应端口组的中断标志为自动置位**

**端口状态标志**寄存器**P0IFG、P1IFG和P2IFG**，分别对应3个端口中隔音教的中断触发状态，当某引脚产生了**设定的外部中断触发信号**时，该寄存器**对应的标志位会自动置位**

>   外部中断标志PxIF和PxIFG必须在中断服务函数中**手工清除**，否则CPU会反复进入中断
>
>   先清除PxIFG，再清除PxIF

![外部中断的工作原理](/img/外部中断的工作原理.jpg)

外部中断相关的寄存器：

: > 寄存器置0中断禁止，置1中断使能

: IEN1的第5位：P0IE(端口0中断使能)

: IEN2的第4位：P1IE(端口1中断使能),IEN2的第1位：P2IE(端口2中断使能)

: Px(P0&P1&P2)IEN寄存器和PICTL寄存器(置0上升沿触发，置1下降沿触发)

1.   ![IEN0中断](/img/IEN0中断.jpg)
2.   ![IEN1中断](/img/IEN1中断.jpg)
3.   ![P2IEN&PICTL](/img/P2IEN&PICTL.jpg)
4.   ![P0IEN&P1IEN&P2IEN端口中断](/img/P0IEN&P1IEN&P2IEN端口中断.jpg)

例：将P1_2和P1_4设置为外部中断引脚，P1_2下降沿触发，P1_4上升沿触发，使能相关中断控制位

```c
void Init_INTP1(){
    P1SEL &= ~0x14;	//P1_2和P1_4设置为通用I/O端口，
    P1DIR &= ~0x14;	//P1_2和P1_4设置为输入模式
    //CC2530芯片复位后，I/O引脚被配置成带上拉的输入模式，故上述两行代码可省略。
    PICTL |= 0x02;	//P1_2的外部中断信号设置为下降沿触发
    PICTL &= ~0x04;	//P1_4的外部中断信号设置为上升沿触发
    P1IEN |= 0x14;	//P1_2和P1_4使能位外部中断引脚
    IEN2 |= 0x10;	//使能P1端口外部中断
    EA = 1;			//打开总中断
}
```



```c
//SW2(P0_1)初始化
void Init_INTP0(){
    P0SEL &= ~0x02;	//设置为I/O

    P0DIR &= ~0x02;	//设置为输入

    P0INP &= ~0x02;	//设置为上拉/下拉

    P2INP &= ~0x20;	//设置为上拉

    IEN1 |= 0x20;	//设置P0端口的中断使能

    P0IEN |= 0x02;	//设置P0_1这个引脚为中断使能

    PICTL |= 0x01;	//设置P0端口为下降沿触发

    EA = 1; 		//打开总中断
}

//4个LED灯初始化
void Init_Port(){
    P1SEL &= ~0x1B; //把P1_4、P1_3、P1_1、P1_0四个端口设置为I/O模式

	P1DIR |= 0x1B;	//把4个端口设置为输出

	P1 &= ~0x1B;	//4个LED灯设置为0(灭)
}

//中断服务函数
#pragma vector = P0INT_VECTOR //向量可以在ioCC2530.h头文件中"Interrupt Vectors"找
__interrupt void Service_INIP0(){
    //P0IFG
    if((P0IFG & 0x02) == 0x02)
        D5 = ~D5;
    
    P0IFG = 0; //手动置0；先IFG，后IF
    P0IF = 0;
}

//延时函数
void Delay(unsigned int t){
    while(t--);
}

void main(){
    Init_Port();
    Init_INTP0();
    while(1){
        D4 = 1;
        Delay(60000);
        Delay(60000);
        D4 = 0;
        Delay(60000);
        Delay(60000);
    }
}
```

>   端口组中断使能 -> 端口组具体引脚中断使能 -> 上升(0)、下降(1)沿触发 -> 总中断使能

pw
